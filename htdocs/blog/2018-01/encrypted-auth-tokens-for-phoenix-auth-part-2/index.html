<!DOCTYPE html>
<html lang="en">
<head>
	<title>Encrypted auth tokens for Phoenix (Auth part 2) - Encrypted online accounting for freelancers with Sealas</title>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta content="width=device-width, initial-scale=1" name="viewport"/>

  <meta name="robots" content="index,follow">
	<meta name="description" content="Zero Knowledge, Open source, Open development. All data stored encrypted, source code open to everyone, blog journey through the whole development.">

	<link rel="alternate" hreflang="de" href="https://sealas.at/" />
	<link rel="alternate" hreflang="en" href="https://sealas.at/en" />

  <link href="/vendor/open-sans-fontface/open-sans.css" rel="stylesheet" type="text/css"/>
	<link rel="stylesheet" type="text/css" href="/vendor/lato/css/lato.min.css">
	<link rel="stylesheet" type="text/css" href="/fonts/fonts-raleway/css/raleway.min.css">
	<link rel="stylesheet" type="text/css" href="/styles/site/font-icons.css?v=1004">
	<link rel="stylesheet" type="text/css" href="/styles/font/crete/stylesheet.css?v=1004">

	<link rel="icon" href="/images/sealas-logo-yellow.png" />
	<link rel="shortcut icon" href="/images/favicon.ico" />

	<link rel="stylesheet" type="text/css" href="/styles/front.css?v=1004">
	<link rel="stylesheet" type="text/css" href="/styles/site.css?v=1004">

	
<meta name="twitter:card"       content="summary">
<meta name="twitter:site"       content="@sealasapp">
<meta property="og:url"         content="https://sealas.at/blog/2018-01/encrypted-auth-tokens-for-phoenix-auth-part-2/">
<meta property="og:title"       content="Encrypted auth tokens for Phoenix (Auth part 2)">
<meta property="og:type"        content="article">
<meta property="og:description" content="Last time, in &lt;a href=&quot;https://sealas.at/blog/2017-12/tokens-cookies-and-sessions-an-auth-story-part-1/&quot;&gt;Tokens, cookies and sessions: an auth story (Part 1)&lt;/a&gt;, we talked about the decision-making process behind our authentication mechanism.">
<meta property="og:image"       content="https://sealas.at/images/sealas-logo-white-yellow.png">


	</head>
	
	
	
	
<body>
	<header id="header">

			<div id="header-wrap">

				<div class="container clearfix">

					<div id="primary-menu-trigger"><i class="icon-reorder"></i></div>
					<div id="logo">
						<a href="/" class="standard-logo" data-dark-logo="images/logo-dark.png"><img src="/images/sealas-logo-white-yellow.png" alt="Encrypted online accounting for freelancers with Sealas"></a>
						<a href="/" class="retina-logo" data-dark-logo="images/logo-dark@2x.png"><img src="/images/sealas-logo-white-yellow.png" alt="Encrypted online accounting for freelancers with Sealas"></a>
					</div><!-- #logo end -->

					<nav id="primary-menu">
						<ul class="one-page-menu sf-js-enabled" style="touch-action: pan-y;">
							
							<li><a href="/en/about"><div>About us</div></a></li>
							
							
							<li><a href="https://github.com/brainsware/sealas" target="_blank"><div>github</div></a></li>
							<li><a href="/blog/"><div>Blog</div></a></li>
						</ul>

						

						<ul class="one-page-menu sf-js-enabled lang-menu">
							<li><a><img src="/images/flags/gb.png" alt="en" /> en</a>
								<ul>
									<li><a href="/de"><img src="/images/flags/at.png" alt="de" /> de</a></li>
									<li><a href="/en"><img src="/images/flags/gb.png" alt="en" /> en</a></li>
								</ul>
							</li>
						</ul>

					</nav>

				</div>

			</div>

		</header>

		<div class="clear"></div>


<section id="content">
<div class="content-wrap">
	<div class="container clearfix">
		<div class="entry clearfix">
			<a href="/blog">&laquo; back to blog</a>
			<div class="entry-title">
				<h1>Encrypted auth tokens for Phoenix (Auth part 2)</h1>
			</div>

			<ul class="entry-meta clearfix">
				<li><i class="icon-calendar3"></i> 08.01.2018</li>
			</ul>

			<div class="entry entry-content">
				<p>Last time, in <a href="https://sealas.at/blog/2017-12/tokens-cookies-and-sessions-an-auth-story-part-1/">Tokens, cookies and sessions: an auth story (Part 1)</a>, we talked about the decision-making process behind our authentication mechanism.</p>
<p>This post will explore the implementation of our very own authentication token library, which you can find here on <a href="https://github.com/Brainsware/authtoken" rel="external" target="_blank" class="external">Github</a>.</p>
<p>We will go over fleshing out an API for working directly with auth tokens, talk about expiring and refreshing tokens.
At the end we&apos;ll cover a router plug to use in a Phoenix project.</p>
<h2 id="what-is-your-function-in-life-">What is your function in life?</h2>
<p>To set our goals and aims straight, let&apos;s keep in mind what we want to do: simple encrypted tokens as means for authentication, which will serve as the baseline which we can improve upon in the future.
Out of all the options that are available within JWT, we want to have <em>one</em> sane setting, that will sufficiently secure our tokens.</p>
<p>With that in mind, we can safely set the mode we use to A128GCM, and pass on the key directly.</p>
<h3 id="why-aes-128-and-not-256-">Why AES 128 and not 256?</h3>
<p>There are <a href="https://www.schneier.com/blog/archives/2009/07/another_new_aes.html" rel="external" target="_blank" class="external">some</a> <a href="https://www.schneier.com/blog/archives/2011/08/new_attack_on_a_1.html" rel="external" target="_blank" class="external">attacks</a> on AES 256 that make it&apos;s key handling &quot;weaker&quot; than that of AES 128, but none have any practical security implications, for now.</p>
<blockquote>
<p><em>And for new applications I suggest that people don&apos;t use AES-256.
AES-128 provides more than enough security margin for the forseeable future.
But if you&apos;re already using AES-256, there&apos;s no reason to change.</em></p>
</blockquote>
<p>Other than this quote from Schneier, AES-128 has the advantage of being slightly faster and slightly smaller in output, while providing a solution that is <em>secure enough</em>.
Another point to keep in mind: tokens are short lived, so if at any point we should discover that AES-128 isn&apos;t secure enough any more, we can simply exchange it for something better.</p>
<h2 id="dependencies">Dependencies</h2>
<p>Since <a href="https://github.com/potatosalad/erlang-jose" rel="external" target="_blank" class="external">JOSE/JWT for Elixir</a> is what we&apos;re using to create this, and Phoenix is the framework we&apos;re building this for, our list of dependencies is going to be pretty straight forward.</p>
<pre><code class="lang-elixir hljs"><span class="hljs-function"><span class="hljs-keyword">defp</span> <span class="hljs-title">deps</span></span> <span class="hljs-keyword">do</span>
  [
    {<span class="hljs-symbol">:jose</span>, <span class="hljs-string">&quot;~&gt; 1.8&quot;</span>},
    {<span class="hljs-symbol">:plug</span>, <span class="hljs-string">&quot;~&gt; 1.4&quot;</span>},
    {<span class="hljs-symbol">:phoenix</span>, <span class="hljs-string">&quot;~&gt; 1.3&quot;</span>},
  ]
<span class="hljs-keyword">end</span>
</code></pre>
<p>Most of the code won&apos;t care about Phoenix or Plug, so you can use it in any project you want, independent of your choice of framework, or lack thereof.</p>
<h2 id="token-api">Token API</h2>
<p>Let&apos;s put together our token API, by first guarding the most basic edges with tests.</p>
<h3 id="keys">Keys</h3>
<p>Encryption usually requires some form of key for the encrypting party, otherwise we would be scrambling into an unrecoverable mess.
AES128 keys need to be 16 bytes in length, so we can simply test for that:</p>
<pre><code class="lang-elixir hljs">describe <span class="hljs-string">&quot;keys&quot;</span> <span class="hljs-keyword">do</span>
  test <span class="hljs-string">&quot;generate_key/0 returns a valid AES128 key&quot;</span> <span class="hljs-keyword">do</span>
    {<span class="hljs-symbol">:ok</span>, key} = AuthToken.generate_key()

    assert byte_size(key) == <span class="hljs-number">16</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>And its very short implementation:</p>
<pre><code class="lang-elixir hljs"><span class="hljs-variable">@spec</span> generate_key() <span class="hljs-symbol">:</span>: {<span class="hljs-symbol">:ok</span>, binary}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_key</span></span> <span class="hljs-keyword">do</span>
  {<span class="hljs-symbol">:ok</span>, <span class="hljs-symbol">:crypto</span>.strong_rand_bytes(<span class="hljs-number">16</span>)}
<span class="hljs-keyword">end</span>
</code></pre>
<p>That key then just goes to <code class="hljs css"><span class="hljs-selector-tag">config</span> <span class="hljs-selector-pseudo">:authtoken</span>, <span class="hljs-selector-pseudo">:token_key</span></code> so we can read it out with <code class="hljs css"><span class="hljs-selector-tag">Application</span><span class="hljs-selector-class">.get_env</span>(<span class="hljs-selector-pseudo">:authtoken</span>, <span class="hljs-selector-pseudo">:token_key)</span></code>.
There is no necessity to make it readable for people, so we can just leave it in its binary format.</p>
<h3 id="tokens">Tokens</h3>
<p>Tokens themselves are very simple and so the only part we really need to verify is whether the encryption and decryption works as expected.</p>
<pre><code class="lang-elixir hljs"><span class="hljs-variable">@user</span> %{<span class="hljs-symbol">id:</span> <span class="hljs-number">123</span>}

describe <span class="hljs-string">&quot;tokens&quot;</span> <span class="hljs-keyword">do</span>
  test <span class="hljs-string">&quot;token generation&quot;</span> <span class="hljs-keyword">do</span>
    {<span class="hljs-symbol">:ok</span>, encrypted_token} = AuthToken.generate_token(<span class="hljs-variable">@user</span>)

    assert {<span class="hljs-symbol">:ok</span>, token} = AuthToken.decrypt_token(encrypted_token)
    assert token[<span class="hljs-string">&quot;id&quot;</span>] == <span class="hljs-variable">@user</span>.id
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>We&apos;ll set up some test data to verify with, generate a token and decrypt it again!</p>
<p>Simple, right?</p>
<p>Yes, but not very useful.</p>
<h3 id="expiration-and-refresh">Expiration and refresh</h3>
<p><em>Intermission: the beauty of <strong>writing down your thoughts </strong>about what you&apos;re doing is making it easier to recognize when you&apos;re doing something <del>stupid</del>suboptimal.
In the first iteration I left out a refresh cycle for the tokens for simplicity&apos;s sake.
The huge downside to this is that you&apos;re keeping your tokens valid for way longer than is sensible in an environment in which you want to be able to revoke access; by removing someone from a project, by deleting your own or someone else&apos;s account, changing permissions or any other reason or set of reasons.</em></p>
<p>Any useful token needs to have some limited time frame within which it is valid.
This is also one of those settings that should have some default value which can be overwritten by other applications&apos; config files.
To that end, we can add this to the package&apos;s application method in mix.exs:</p>
<pre><code class="lang-elixir hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">application</span></span> <span class="hljs-keyword">do</span>
  [<span class="hljs-symbol">applications:</span> [<span class="hljs-symbol">:logger</span>, <span class="hljs-symbol">:plug</span>],
  <span class="hljs-symbol">env:</span> [
    <span class="hljs-symbol">timeout:</span> <span class="hljs-number">86400</span>,
    <span class="hljs-symbol">refresh:</span> <span class="hljs-number">1800</span>
  ]]
<span class="hljs-keyword">end</span>
</code></pre>
<p>With these defaults we have the total lifetime of a token set to one day, with a refresh rate of 30 minutes.
This means that a user will need to do provide their credentials only once per day.
The client however needs to request a new token once per refresh cycle - 30 minutes in this case - which denotes the time window of total trust we want to put into a single token.
After that we can refresh the token and use that opportunity to check with the backend if the user is still legible for access.</p>
<p>So, to validate that we have a usable token meeting our requirements, let&apos;s extend our test for the tokens:</p>
<pre><code class="lang-elixir hljs">test <span class="hljs-string">&quot;token generation&quot;</span> <span class="hljs-keyword">do</span>
  {<span class="hljs-symbol">:ok</span>, encrypted_token} = AuthToken.generate_token(<span class="hljs-variable">@user</span>)

  assert {<span class="hljs-symbol">:ok</span>, token} = AuthToken.decrypt_token(encrypted_token)
  assert token[<span class="hljs-string">&quot;id&quot;</span>] == <span class="hljs-variable">@user</span>.id

  refute AuthToken.is_timedout?(token)
  refute AuthToken.needs_refresh?(token)

  Application.put_env(<span class="hljs-symbol">:authtoken</span>, <span class="hljs-symbol">:timeout</span>, -<span class="hljs-number">1</span>)
  Application.put_env(<span class="hljs-symbol">:authtoken</span>, <span class="hljs-symbol">:refresh</span>, -<span class="hljs-number">1</span>)

  assert AuthToken.is_timedout?(token)
  assert AuthToken.needs_refresh?(token)
<span class="hljs-keyword">end</span>
</code></pre>
<p>Newly generated tokens should neither be timed out nor need a refresh, so both <code class="hljs ceylon"><span class="hljs-keyword">is</span><span class="hljs-number">_</span>timedout?/<span class="hljs-number">1</span></code> and <code class="hljs jboss-cli">needs_refresh?<span class="hljs-string">/1</span></code>  should return false.
To ensure that both functions actually do their job, we can reduce the time to timeout and refresh to -1, so they always return true and assert that that&apos;s happening.</p>
<p>That was easy enough, so now it&apos;s</p>
<h3 id="implementation-time">Implementation time</h3>
<p>First let&apos;s get dirty and generate some encrypted tokens.
Looking at the <a href="https://hexdocs.pm/jose/JOSE.html#content" rel="external" target="_blank" class="external">JOSE documentation</a>, it is very easy to get overwhelmed and maybe go a bit insane; and get reminded why having a reduced set of options is actually a nice thing, if you don&apos;t want to die of choice paralysis.</p>
<p>But since we already know what we&apos;re going for, we can just look at what we need for our implementation case.
To generate our token we need an encryption header (JWE):</p>
<pre><code class="lang-elixir hljs">%{ <span class="hljs-string">&quot;alg&quot;</span> =&gt; <span class="hljs-string">&quot;dir&quot;</span>, <span class="hljs-string">&quot;enc&quot;</span> =&gt; <span class="hljs-string">&quot;A128GCM&quot;</span>, <span class="hljs-string">&quot;typ&quot;</span> =&gt; <span class="hljs-string">&quot;JWT&quot;</span> }
</code></pre>
<p>which we can just put in a private function <code class="hljs elixir"><span class="hljs-function"><span class="hljs-keyword">defp</span> <span class="hljs-title">get_jwe</span></span></code>.
<code class="hljs ebnf"><span class="hljs-attribute">alg</span></code> set to  <code class="hljs dos"><span class="hljs-built_in">dir</span></code> means we don&apos;t need any key wrapping or derivation function, since we&apos;re supplying our own key in the correct size already.</p>
<p>Second we need a key (JWK), which we can generate with <code class="hljs stylus">JOSE<span class="hljs-selector-class">.JWK</span><span class="hljs-selector-class">.from_oct</span>/<span class="hljs-number">1</span></code>.
This we can also put into a private helper function:</p>
<pre><code class="lang-elixir hljs"><span class="hljs-variable">@spec</span> get_jwk() <span class="hljs-symbol">:</span>: %JOSE.JWK{}
<span class="hljs-function"><span class="hljs-keyword">defp</span> <span class="hljs-title">get_jwk</span></span> <span class="hljs-keyword">do</span>
  get_config(<span class="hljs-symbol">:token_key</span>)
  |&gt; JOSE.JWK.from_oct()
<span class="hljs-keyword">end</span>
</code></pre>
<p><code class="hljs lsl">get_config/<span class="hljs-number">1</span></code> is a simple wrapper function for <code class="hljs css"><span class="hljs-selector-tag">Application</span><span class="hljs-selector-class">.get_env</span>(<span class="hljs-selector-pseudo">:authtoken</span>, <span class="hljs-selector-pseudo">:atom)</span></code> which throws an error if the specified atom is not set.</p>
<p>Alright, with this done, we can piece together a nice and simple function generating us our tokens.</p>
<pre><code class="lang-elixir hljs"><span class="hljs-variable">@spec</span> generate_token(map) <span class="hljs-symbol">:</span>: {<span class="hljs-symbol">:ok</span>, String.t}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_token</span></span>(user_data) <span class="hljs-keyword">do</span>
  token_content = %{<span class="hljs-symbol">ct:</span> DateTime.to_unix(DateTime.utc_now())} |&gt; Enum.into(user_data)

  jwt = JOSE.JWT.encrypt(get_jwk(), get_jwe(), token_content) |&gt; JOSE.JWE.compact |&gt; elem(<span class="hljs-number">1</span>)

  <span class="hljs-comment"># Remove JWT header</span>
  {<span class="hljs-symbol">:ok</span>, Regex.run(~r/.+?\.(.+)/, jwt) |&gt; List.last}
<span class="hljs-keyword">end</span>
</code></pre>
<p>Taking an arbitrary map of data, we insert a creation time, do the conversion and then snip off the token&apos;s header by removing everything up to the first <code class="hljs erlang">.</code>  with a quick regex.
Since the library only provides us with standard compliant JWTs, this is the way to go here.</p>
<p>Decrypting our tokens is going to be similarly easy.
We have to rebuild our decapitated token, which we can easily do with our helper function <code class="hljs lsl">get_jwe/<span class="hljs-number">0</span></code>  and a base64 encoding, since all JWTs are base64 encoded.</p>
<pre><code class="lang-elixir hljs">header = get_jwe() |&gt; JOSE.Poison.lexical_encode! |&gt; <span class="hljs-symbol">:base64url</span>.encode

auth_token = header &lt;&gt; <span class="hljs-string">&quot;.&quot;</span> &lt;&gt; headless_token
</code></pre>
<p>Now all we need to do is <code class="hljs actionscript"><span class="hljs-keyword">try</span> <span class="hljs-keyword">do</span></code> decrypt with our key, and return</p>
<pre><code class="lang-elixir hljs">try <span class="hljs-keyword">do</span>
  %{<span class="hljs-symbol">fields:</span> token} = JOSE.JWT.decrypt(get_jwk(), auth_token) |&gt; elem(<span class="hljs-number">1</span>)

  {<span class="hljs-symbol">:ok</span>, token}
rescue
  <span class="hljs-number">_</span> -&gt; {<span class="hljs-symbol">:error</span>}
<span class="hljs-keyword">end</span>
</code></pre>
<p>Last but not least we need to add the helper functions for checking the freshness of our tokens.
These would simply read out the configured value for the respective time frames and return either true or false:</p>
<pre><code class="lang-elixir hljs"><span class="hljs-variable">@spec</span> is_timedout?(map) <span class="hljs-symbol">:</span>: boolean
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_timedout?</span></span>(token) <span class="hljs-keyword">do</span>
  {<span class="hljs-symbol">:ok</span>, ct} = DateTime.from_unix(token[<span class="hljs-string">&quot;ct&quot;</span>])

  DateTime.diff(DateTime.utc_now(), ct) &gt; get_config(<span class="hljs-symbol">:timeout</span>)
<span class="hljs-keyword">end</span>

<span class="hljs-variable">@spec</span> needs_refresh?(map) <span class="hljs-symbol">:</span>: boolean
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">needs_refresh?</span></span>(token) <span class="hljs-keyword">do</span>
  {<span class="hljs-symbol">:ok</span>, rt} = DateTime.from_unix(token[<span class="hljs-string">&quot;rt&quot;</span>])

  DateTime.diff(DateTime.utc_now(), rt) &gt; get_config(<span class="hljs-symbol">:refresh</span>)
<span class="hljs-keyword">end</span>
</code></pre>
<h3 id="regeneration">Regeneration</h3>
<p>So far so good, what&apos;s missing now is a way to refresh stale tokens.
A function providing this should give us a token with the same creation time, but a new refresh time -- if the token actually is eligible for regeneration; so only if it&apos;s not still fresh and if it&apos;s not timed out.</p>
<pre><code class="lang-elixir hljs">test <span class="hljs-string">&quot;token refresh&quot;</span> <span class="hljs-keyword">do</span>
  {<span class="hljs-symbol">:ok</span>, encrypted_token} = AuthToken.generate_token(<span class="hljs-variable">@user</span>)
  {<span class="hljs-symbol">:ok</span>, token} = AuthToken.decrypt_token(encrypted_token)

  assert AuthToken.refresh_token(token) == {<span class="hljs-symbol">:error</span>, <span class="hljs-symbol">:stillfresh</span>}

  <span class="hljs-symbol">:timer</span>.sleep(<span class="hljs-number">1000</span>)

  Application.put_env(<span class="hljs-symbol">:authtoken</span>, <span class="hljs-symbol">:refresh</span>, -<span class="hljs-number">1</span>)
  assert {<span class="hljs-symbol">:ok</span>, fresh_token} = AuthToken.refresh_token(token)

  {<span class="hljs-symbol">:ok</span>, token} = AuthToken.decrypt_token(fresh_token)
  assert token[<span class="hljs-string">&quot;ct&quot;</span>] &lt; token[<span class="hljs-string">&quot;rt&quot;</span>]

  Application.put_env(<span class="hljs-symbol">:authtoken</span>, <span class="hljs-symbol">:timeout</span>, -<span class="hljs-number">1</span>)
  assert AuthToken.refresh_token(token) == {<span class="hljs-symbol">:error</span>, <span class="hljs-symbol">:timedout</span>}
<span class="hljs-keyword">end</span>
</code></pre>
<p>This covers what we described pretty well, and implementing it should also pretty straight forward, especially given that we already have some working helper functions:</p>
<pre><code class="lang-elixir hljs"><span class="hljs-variable">@spec</span> refresh_token(map) <span class="hljs-symbol">:</span>: {<span class="hljs-symbol">:ok</span>, String.t} | {<span class="hljs-symbol">:error</span>, <span class="hljs-symbol">:stillfresh</span>} | {<span class="hljs-symbol">:error</span>, <span class="hljs-symbol">:timedout</span>}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">refresh_token</span></span>(token) <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">cond</span> <span class="hljs-keyword">do</span>
    is_timedout?(token) -&gt;    {<span class="hljs-symbol">:error</span>, <span class="hljs-symbol">:timedout</span>}
    !needs_refresh?(token) -&gt; {<span class="hljs-symbol">:error</span>, <span class="hljs-symbol">:stillfresh</span>}

    needs_refresh?(token) -&gt;
      token = %{<span class="hljs-string">&quot;rt&quot;</span> =&gt; DateTime.to_unix(DateTime.utc_now())} |&gt; Enum.into(token)

      generate_token(token)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>We can easily increase the usability of this function here by making it possible to directly refresh a still encrypted token you receive from the client.
Elixir&apos;s guards make this beautifully elegant.
First let&apos;s add one to the existing function:</p>
<pre><code class="lang-elixir hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">refresh_token</span></span>(token) <span class="hljs-keyword">when</span> is_map(token) <span class="hljs-keyword">do</span>
</code></pre>
<p>Sweet! Now what we need is another function accepting string tokens attempting to decrypt and then refresh them.
Also, I&apos;m going to let you figure out how to extend the test cases for this yourself, and if you want you can even pretend to have written the tests first.</p>
<pre><code class="lang-elixir hljs"><span class="hljs-variable">@spec</span> refresh_token(String.t) <span class="hljs-symbol">:</span>: {<span class="hljs-symbol">:ok</span>, String.t} | {<span class="hljs-symbol">:error</span>, <span class="hljs-symbol">:stillfresh</span>} | {<span class="hljs-symbol">:error</span>, <span class="hljs-symbol">:timedout</span>}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">refresh_token</span></span>(token) <span class="hljs-keyword">when</span> is_binary(token) <span class="hljs-keyword">do</span>
  decrypt_token(token)
  |&gt; refresh_token
<span class="hljs-keyword">end</span>
</code></pre>
<h2 id="plug-me-baby">Plug me baby</h2>
<p>A plug is what&apos;s going to make the whole process of checking tokens easily integrated in our (or our user&apos;s) future routers.
We are going to be covering one use-case, that I think is the most common: block all requests with invalid tokens with a <code class="hljs lsl"><span class="hljs-number">401</span></code> and let through (i.e. do nothing) those with valid tokens.</p>
<p>JWTs usually get sent with the <code class="hljs ebnf"><span class="hljs-attribute">authorization</span></code> header with <code class="hljs avrasm"><span class="hljs-symbol">bearer:</span></code> prefixed.
We&apos;ll stick to this standard here.</p>
<p>Again, let&apos;s start out with writing down our wishes and requirements in the form of tests.
They&apos;re such a useful tool to help you remember what you would like your software to look like when it&apos;s all grown up.</p>
<h3 id="test-for-no-token-existing">Test for no token existing</h3>
<p>The simplest test case is to send a request with no special auth header set:</p>
<pre><code class="lang-elixir hljs">test <span class="hljs-string">&quot;denying access for no token&quot;</span>, %{<span class="hljs-symbol">conn:</span> conn} <span class="hljs-keyword">do</span>
  conn = AuthToken.Plug.verify_token(conn, [])

  assert json_response(conn, <span class="hljs-number">401</span>)
<span class="hljs-keyword">end</span>
</code></pre>
<h3 id="test-for-wrong-token">Test for &quot;wrong&quot; token</h3>
<p>This could be anything from a malicious token to one so old that your key for generating them has changed a few times already.</p>
<pre><code class="lang-elixir hljs">test <span class="hljs-string">&quot;denying access for wrong token&quot;</span>, %{<span class="hljs-symbol">conn:</span> conn} <span class="hljs-keyword">do</span>
  conn = conn
  |&gt; put_req_header(<span class="hljs-string">&quot;authorization&quot;</span>, <span class="hljs-string">&quot;bearer: &quot;</span>)
  |&gt; AuthToken.Plug.verify_token([])

  assert json_response(conn, <span class="hljs-number">401</span>)
<span class="hljs-keyword">end</span>
</code></pre>
<h3 id="test-for-stale-and-expired-tokens">Test for stale and expired tokens</h3>
<p>For this one, we can again just set the refresh and timeout value to -1, which will make all tokens expire or require regeneration immediately.</p>
<pre><code class="lang-elixir hljs">test <span class="hljs-string">&quot;denying access for stale or expired token&quot;</span>, %{<span class="hljs-symbol">conn:</span> conn} <span class="hljs-keyword">do</span>
  {<span class="hljs-symbol">:ok</span>, token} = AuthToken.generate_token(<span class="hljs-variable">@user</span>)

  Application.put_env(<span class="hljs-symbol">:authtoken</span>, <span class="hljs-symbol">:refresh</span>, -<span class="hljs-number">1</span>)

  conn = conn
  |&gt; put_req_header(<span class="hljs-string">&quot;authorization&quot;</span>, <span class="hljs-string">&quot;bearer: &quot;</span> &lt;&gt; token)
  |&gt; AuthToken.Plug.verify_token([])

  assert json_response(conn, <span class="hljs-number">401</span>) == %{<span class="hljs-string">&quot;error&quot;</span> =&gt; <span class="hljs-string">&quot;needs_refresh&quot;</span>}

  Application.put_env(<span class="hljs-symbol">:authtoken</span>, <span class="hljs-symbol">:timeout</span>, -<span class="hljs-number">1</span>)

  assert Application.get_env(<span class="hljs-symbol">:authtoken</span>, <span class="hljs-symbol">:timeout</span>) == -<span class="hljs-number">1</span>

  conn = conn
  |&gt; recycle()
  |&gt; put_req_header(<span class="hljs-string">&quot;authorization&quot;</span>, <span class="hljs-string">&quot;bearer: &quot;</span> &lt;&gt; token)
  |&gt; AuthToken.Plug.verify_token([])

  assert json_response(conn, <span class="hljs-number">401</span>) == %{<span class="hljs-string">&quot;error&quot;</span> =&gt; <span class="hljs-string">&quot;timeout&quot;</span>}
<span class="hljs-keyword">end</span>
</code></pre>
<h3 id="test-for-valid-tokens">Test for valid tokens</h3>
<p>Just generate a token and expect the request to go through.</p>
<pre><code class="lang-elixir hljs">test <span class="hljs-string">&quot;granting access for correct token&quot;</span>, %{<span class="hljs-symbol">conn:</span> conn} <span class="hljs-keyword">do</span>
  {<span class="hljs-symbol">:ok</span>, token} = AuthToken.generate_token(<span class="hljs-variable">@user</span>)

  conn = conn
  |&gt; put_req_header(<span class="hljs-string">&quot;authorization&quot;</span>, <span class="hljs-string">&quot;bearer: &quot;</span> &lt;&gt; token)
  |&gt; AuthToken.Plug.verify_token([])

  assert conn.status != <span class="hljs-number">401</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h3 id="do-it">Do it</h3>
<p>Having covered a good range of cases, we can attempt to implement this.
If we want this module to be usable as a plug, we have to <code class="hljs elm"><span class="hljs-keyword">import</span> Plug.Conn</code>, which gives the module access to all the necessary functionality.</p>
<p>First we&apos;ll try to verify if the given token is decryptable at all.
Let&apos;s extract the token from the request header:</p>
<pre><code class="lang-elixir hljs">token_header = get_req_header(conn, <span class="hljs-string">&quot;authorization&quot;</span>) |&gt; List.first

crypto_token = if token_header, <span class="hljs-symbol">do:</span> Regex.run(~r/(bearer\: )?(.+)/, token_header) |&gt; List.last
</code></pre>
<p>We don&apos;t need the <code class="hljs avrasm"><span class="hljs-symbol">bearer:</span></code> portion, so a quick Regex will get rid of that.
Next we can pass it through <code class="hljs lsl">AuthToken.decrypt_token/<span class="hljs-number">1</span></code> and return accordingly.
In case it fails, we send back a <code class="hljs lsl"><span class="hljs-number">401</span></code> with the JSON encoded error message <code class="hljs">auth_fail</code>.
Don&apos;t forget to call <code class="hljs cos"><span class="hljs-keyword">halt</span>/<span class="hljs-number">0</span></code> to tell Plug that this request is done and no further action is needed.
A client can then use this as a keyword for translation or redirect to a login page.
Or crash the browser if it&apos;s feeling frisky.</p>
<pre><code class="lang-elixir hljs"><span class="hljs-keyword">case</span> AuthToken.decrypt_token(crypto_token) <span class="hljs-keyword">do</span>
  {<span class="hljs-symbol">:error</span>} -&gt;
    conn
    |&gt; put_resp_content_type(<span class="hljs-string">&quot;application/json&quot;</span>)
    |&gt; send_resp(<span class="hljs-symbol">:unauthorized</span>, <span class="hljs-string">&quot;{\&quot;error\&quot;: \&quot;auth_fail\&quot;}&quot;</span>)
    |&gt; halt
  {<span class="hljs-symbol">:ok</span>, token} -&gt;
    conn
<span class="hljs-keyword">end</span>
</code></pre>
<p>The success case could just end here, but there&apos;s still the case of a timed out token, so let&apos;s extend that to</p>
<pre><code class="lang-elixir hljs">{<span class="hljs-symbol">:ok</span>, token} -&gt;
  conn |&gt; check_token_time(token)
</code></pre>
<p>and pass it on to the next method validating the time.
In case it fails here, we&apos;re going to return the error message <code class="hljs applescript"><span class="hljs-keyword">timeout</span></code>.
Apart from that it is pretty similar to <code class="hljs">verify_token</code>.
Here&apos;s the full code for both functions:</p>
<pre><code class="lang-elixir hljs">import Plug.Conn

<span class="hljs-variable">@spec</span> verify_token(Plug.Conn.t, any) <span class="hljs-symbol">:</span>: Plug.Conn.t
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">verify_token</span></span>(conn, _options) <span class="hljs-keyword">do</span>
  token_header = get_req_header(conn, <span class="hljs-string">&quot;authorization&quot;</span>) |&gt; List.first

  crypto_token = if token_header, <span class="hljs-symbol">do:</span> Regex.run(~r/(bearer\: )?(.+)/, token_header) |&gt; List.last

  <span class="hljs-keyword">case</span> AuthToken.decrypt_token(crypto_token) <span class="hljs-keyword">do</span>
    {<span class="hljs-symbol">:error</span>} -&gt;
      conn
      |&gt; put_resp_content_type(<span class="hljs-string">&quot;application/json&quot;</span>)
      |&gt; send_resp(<span class="hljs-symbol">:unauthorized</span>, <span class="hljs-string">&quot;{\&quot;error\&quot;: \&quot;auth_fail\&quot;}&quot;</span>)
      |&gt; halt
    {<span class="hljs-symbol">:ok</span>, token} -&gt;
      conn |&gt; check_token_time(token)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-variable">@spec</span> check_token_time(Plug.Conn.t, map) <span class="hljs-symbol">:</span>: Plug.Conn.t
<span class="hljs-function"><span class="hljs-keyword">defp</span> <span class="hljs-title">check_token_time</span></span>(conn, token) <span class="hljs-keyword">do</span>
  timeout = AuthToken.get_config(<span class="hljs-symbol">:timeout</span>)

  {<span class="hljs-symbol">:ok</span>, ct} = DateTime.from_unix(token[<span class="hljs-string">&quot;ct&quot;</span>])

  <span class="hljs-keyword">cond</span> <span class="hljs-keyword">do</span>
    AuthToken.is_timedout?(token) -&gt;
      conn
      |&gt; put_resp_content_type(<span class="hljs-string">&quot;application/json&quot;</span>)
      |&gt; send_resp(<span class="hljs-symbol">:unauthorized</span>, <span class="hljs-string">&quot;{\&quot;error\&quot;: \&quot;timeout\&quot;}&quot;</span>)
      |&gt; halt
    AuthToken.needs_refresh?(token) -&gt;
      conn
      |&gt; put_resp_content_type(<span class="hljs-string">&quot;application/json&quot;</span>)
      |&gt; send_resp(<span class="hljs-symbol">:unauthorized</span>, <span class="hljs-string">&quot;{\&quot;error\&quot;: \&quot;needs_refresh\&quot;}&quot;</span>)
      |&gt; halt
    <span class="hljs-keyword">true</span> -&gt;
      conn
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2 id="future-improvements">Future Improvements</h2>
<p>That&apos;s a good base package for our simple encrypted auth tokens.
There is always room for improvement though, and writing down helps with not forgetting future plans.</p>
<p>One thing that could greatly improve usability -- and at the same time security -- would be an automated key management.
Keys could then be kept by the server for the duration of the timeout and then replaced by a new key, thus ensuring constant rotation.</p>
<p>Next time we&apos;ll look at assembling what we have into a more complete authentication API.</p>

			</div>

			<div class="si-share noborder clearfix">
				<span>Share this Post:</span>
				<div>
					<div id="fb-root"></div>
					<script>(function(d, s, id) {
					  var js, fjs = d.getElementsByTagName(s)[0];
					  if (d.getElementById(id)) return;
					  js = d.createElement(s); js.id = id;
					  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
					  fjs.parentNode.insertBefore(js, fjs);
					}(document, 'script', 'facebook-jssdk'));</script>

						<fb:like href='https://sealas.at/blog/2018-01/encrypted-auth-tokens-for-phoenix-auth-part-2/'
         send='false'
         layout='button'
         show_faces=''
         width='80'
         action=''
         font=''
         colorscheme=''
         ref='' ></fb:like>

				 <a href="https://twitter.com/share" class="twitter-share-button" data-text="Encrypted auth tokens for Phoenix (Auth part 2)" data-url="https://sealas.at/blog/2018-01/encrypted-auth-tokens-for-phoenix-auth-part-2/" data-via="SealasApp" data-dnt="true" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

				 <!-- Place this tag where you want the +1 button to render. -->
				<div class="g-plusone" data-size="medium" data-annotation="none" data-callback="https://sealas.at/blog/2018-01/encrypted-auth-tokens-for-phoenix-auth-part-2/"></div>

				<!-- Place this tag after the last +1 button tag. -->
				<script type="text/javascript">
				  (function() {
				    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
				    po.src = 'https://apis.google.com/js/platform.js';
				    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
				  })();
				</script>

				<script src="//platform.linkedin.com/in.js" type="text/javascript"> lang: en_US</script>
<script type="IN/Share" data-url="https://sealas.at/blog/2018-01/encrypted-auth-tokens-for-phoenix-auth-part-2/"></script>
				</div>
			</div>

			<div class="post-navigation clearfix">
				<div class="col_half nobottommargin">
					
					<a href="/blog/2017-12/tokens-cookies-and-sessions-an-auth-story-part-1/"><i class="icon-arrow-left"></i> Tokens, cookies and sessions: an auth story (Part 1)</a>
					
				</div>
				<div class="col_half col_last tright nobottommargin">
					
					<a href="/blog/2018-01/designing-and-writing-a-basic-authentication-api-with-phoenix-and-elixir-auth-part-3/">Designing and writing a basic authentication API with Phoenix and Elixir (Auth Part 3) <i class="icon-arrow-right"></i></a>
					
				</div>
			</div>

		</div>
		<div id="section-buy" class="promo promo-border">

	<div class="clearfix">

		<div id="mc_embed_signup" class="widget subscribe-widget clearfix col-md-10 col-md-offset-1">
			<form action="//sealas.us13.list-manage.com/subscribe/post?u=26cea96bbfb24fbc5f58e314f&amp;id=a92e310c11" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
				<div id="mc_embed_signup_scroll">
				<h3 style="margin-bottom: 1em;"><span>App development, UX design, business:</span> we're writing about the entire development of Sealas</h3>

				<div class="input-group input-group-lg divcenter">
					<span class="input-group-addon"><i class="icon-email2"></i></span>
					<input type="email" value="" required="required" name="EMAIL" class="form-control required email" id="mce-EMAIL" placeholder="Enter your email address here">

					<span class="input-group-btn">
						<button class="btn btn-success" type="submit">Subscribe</button>
					</span>
				</div>
				<div id="mce-responses" class="clear">
					<div class="response" id="mce-error-response" style="display:none"></div>
					<div class="response" id="mce-success-response" style="display:none"></div>
				</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
					<div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_26cea96bbfb24fbc5f58e314f_a92e310c11" tabindex="-1" value=""></div>
					<div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
					</div>
			</form>

			
		</div>
	</div>

</div>

	</div>

</div>
</section>


	<footer id="footer" class="dark" style="background: url('/styles/site/images/footer-bg.jpg') repeat fixed; background-size: 100% 100%;">

		<div class="container">

			
			<div class="footer-widgets-wrap clearfix">

				<div class="col_three_fifth">

					<div class="widget clearfix">

						<img src="/images/sealas-logo-yellow-side.png" alt="Encrypted online accounting for freelancers with Sealas" class="alignleft" id="footer-logo">

						<h3>The <strong>S</strong>ecure <strong>E</strong>asy <strong>A</strong>nd <strong>L</strong>ovely <strong>A</strong>ccounting <strong>S</strong>oftware for freelancers and small businesses.</h3>

						<div class="line" style="margin: 30px 0;"></div>
						<div class="clearfix" style="padding: 10px 0;">
							<div class="col_half">
								<address class="nobottommargin">
									<abbr title="Headquarters" style="display: inline-block;margin-bottom: 7px;"><strong>Imprint:</strong></abbr><br>
									Sealas is a service by<br>
									<a href="https://brainsware.at" target="_blank">Brainsware OG</a><br>
									Liechtensteinstra√üe 119/21<br>
									A-1090 Wien
								</address>
							</div>
							<div class="col_half col_last">
								<br>ATU68014409<br />
								HG Wien, FN 330963k<br />
								<abbr title="Email Address"><strong>Email:</strong></abbr> <a href="mailto:contact@sealas.at">contact@sealas.at</a><br>
								<abbr title="Web"><strong>Web:</strong></abbr> <a href="https://brainsware.at">https://brainsware.at</a><br>
							</div>
						</div>
					</div>

				</div>

				<div class="col_one_fifth">
					<div class="bottommargin-sm widget_links">
						<ul>
							<li><a href="/">Home</a></li>
							<li><a href="/en/about">About us</a></li>
							<li><a href="/#features">Features</a></li>
							
							<li><a href="/en/pricing">Pricing</a></li>
							
							<li><a href="https://github.com/brainsware/sealas-site">Sealas Website on Github</a></li>
							<li><a href="https://github.com/brainsware/sealas">Sealas App on Github</a></li>
						</ul>
					</div>
				</div>
				<div class="col_one_fifth col_last">
					<div class="bottommargin-sm widget_links">
						<ul>
							<li><a href="/en/blog/"><div>Blog</div></a></li>
							<li><a href="/en/contact">Contact</a></li>
							<li><a href="/en/agb">TOS</a></li>
							<li><a href="/en/privacy">Privacy Policy</a></li>
						</ul>
					</div>
				</div>

			</div>

		</div>

		
		<div id="copyrights">

			<div class="container clearfix">

				<div class="col_half">
					&copy; Brainsware OG
				</div>

				<div class="col_half col_last tright">
					<div class="fright clearfix">
						<a href="https://facebook.com/sealasapp" target="_blank" class="social-icon si-small si-borderless nobottommargin si-facebook">
							<i class="icon-facebook"></i>
							<i class="icon-facebook"></i>
						</a>

						<a href="https://twitter.com/sealasapp" target="_blank" class="social-icon si-small si-borderless nobottommargin si-twitter">
							<i class="icon-twitter"></i>
							<i class="icon-twitter"></i>
						</a>

						

						<a href="https://plus.google.com/+SealasAt" target="_blank" class="social-icon si-small si-borderless nobottommargin si-gplus">
							<i class="icon-gplus"></i>
							<i class="icon-gplus"></i>
						</a>

						<a href="https://www.linkedin.com/company/sealas" target="_blank" class="social-icon si-small si-borderless nobottommargin si-linkedin">
							<i class="icon-linkedin"></i>
							<i class="icon-linkedin"></i>
						</a>

						<a href="https://github.com/brainsware" target="_blank" class="social-icon si-small si-borderless nobottommargin si-github">
							<i class="icon-github"></i>
							<i class="icon-github"></i>
						</a>
					</div>
				</div>

			</div>

		</div>

	</footer>

	<script type="text/javascript" src="/site.js">
	</script>

	<noscript><p><img src="//stats.esotericsystems.at/piwik.php?idsite=13" style="border:0;" alt="" /></p></noscript>
</body>
</html>
