<!DOCTYPE html>
<html lang="en">
<head>
	<title>Designing and writing a basic authentication API with Phoenix and Elixir (Auth Part 3) - Encrypted online accounting for freelancers with Sealas</title>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta content="width=device-width, initial-scale=1" name="viewport"/>

  <meta name="robots" content="index,follow">
	<meta name="description" content="Zero Knowledge, Open source, Open development. All data stored encrypted, source code open to everyone, blog journey through the whole development.">

	<link rel="alternate" hreflang="de" href="https://sealas.at/" />
	<link rel="alternate" hreflang="en" href="https://sealas.at/en" />

  <link href="/vendor/open-sans-fontface/open-sans.css" rel="stylesheet" type="text/css"/>
	<link rel="stylesheet" type="text/css" href="/vendor/lato/css/lato.min.css">
	<link rel="stylesheet" type="text/css" href="/vendor/fonts-raleway/css/raleway.min.css">
	<link rel="stylesheet" type="text/css" href="/styles/site/font-icons.css?v=1004">
	<link rel="stylesheet" type="text/css" href="/styles/font/crete/stylesheet.css?v=1004">

	<link rel="icon" href="/images/sealas-logo-yellow.png" />
	<link rel="shortcut icon" href="/images/favicon.ico" />

	<link rel="stylesheet" type="text/css" href="/styles/front.css?v=1004">
	<link rel="stylesheet" type="text/css" href="/styles/site.css?v=1004">

	
<meta name="twitter:card"       content="summary">
<meta name="twitter:site"       content="@sealasapp">
<meta property="og:url"         content="https://sealas.at/blog/2018-01/designing-and-writing-a-basic-authentication-api-with-phoenix-and-elixir-auth-part-3/">
<meta property="og:title"       content="Designing and writing a basic authentication API with Phoenix and Elixir (Auth Part 3)">
<meta property="og:type"        content="article">
<meta property="og:description" content="Continuing this series on writing and developing an authentication process with Phoenix and Elixir, so far we&#39;ve covered developing our authentication library &lt;a href=&quot;https://github.com/Brainsware/authtoken&quot;&gt;authtoken&lt;/a&gt; in part &lt;a href=&quot;https://sealas.at/blog/2017-12/tokens-cookies-and-sessions-an-auth-story-part-1/&quot;&gt;1&lt;/a&gt; and &lt;a href=&quot;https://sealas.at/blog/2018-01/encrypted-auth-tokens-for-phoenix-auth-part-2/&quot;&gt;2&lt;/a&gt;.">
<meta property="og:image"       content="https://sealas.at/images/sealas-logo-white-yellow.png">


	</head>
	
	
	
	
<body>
	<header id="header">

			<div id="header-wrap">

				<div class="container clearfix">

					<div id="primary-menu-trigger"><i class="icon-reorder"></i></div>
					<div id="logo">
						<a href="/" class="standard-logo" data-dark-logo="images/logo-dark.png"><img src="/images/sealas-logo-white-yellow.png" alt="Encrypted online accounting for freelancers with Sealas"></a>
						<a href="/" class="retina-logo" data-dark-logo="images/logo-dark@2x.png"><img src="/images/sealas-logo-white-yellow.png" alt="Encrypted online accounting for freelancers with Sealas"></a>
					</div><!-- #logo end -->

					<nav id="primary-menu">
						<ul class="one-page-menu sf-js-enabled" style="touch-action: pan-y;">
							
							<li><a href="/en/about"><div>About us</div></a></li>
							
							
							<li><a href="https://github.com/brainsware/sealas" target="_blank"><div>github</div></a></li>
							<li><a href="/blog/"><div>Blog</div></a></li>
						</ul>

						

						<ul class="one-page-menu sf-js-enabled lang-menu">
							<li><a><img src="/images/flags/gb.png" alt="en" /> en</a>
								<ul>
									<li><a href="/de"><img src="/images/flags/at.png" alt="de" /> de</a></li>
									<li><a href="/en"><img src="/images/flags/gb.png" alt="en" /> en</a></li>
								</ul>
							</li>
						</ul>

					</nav>

				</div>

			</div>

		</header>

		<div class="clear"></div>


<section id="content">
<div class="content-wrap">
	<div class="container clearfix">
		<div class="entry clearfix">
			<a href="/blog">&laquo; back to blog</a>
			<div class="entry-title">
				<h1>Designing and writing a basic authentication API with Phoenix and Elixir (Auth Part 3)</h1>
			</div>

			<ul class="entry-meta clearfix">
				<li><i class="icon-calendar3"></i> 26.01.2018</li>
			</ul>

			<div class="entry entry-content">
				<p>Continuing this series on writing and developing an authentication process with Phoenix and Elixir, so far we&apos;ve covered developing our authentication library <a href="https://github.com/Brainsware/authtoken" rel="external" target="_blank" class="external">authtoken</a> in part <a href="https://sealas.at/blog/2017-12/tokens-cookies-and-sessions-an-auth-story-part-1/">1</a> and <a href="https://sealas.at/blog/2018-01/encrypted-auth-tokens-for-phoenix-auth-part-2/">2</a>.</p>
<p>In this part (#3) we will cover the most basic necessities for a working authentication.
We will cover the basic structure in our app, including a custom ecto type to handle our password hashing and working with our token library.</p>
<p>So, what are we doing here?</p>
<p>APIs provide you with resources you need or want in another part of an application, or in another application entirely.
In the case of Sealas we want to provide our resources through a REST API to our front-end application.
When writing an interface like this, you usually don&apos;t want to give everyone access to everything; you want to give each user access specifically to their respective resources.
So let&apos;s protect it with a layer of authentication!</p>
<h2 id="packages-and-parts">Packages and parts</h2>
<p>Our users need to identify themselves via some kind of password, which at no point ever should be stored in cleartext.
To that end, we&apos;re going to use a password hashing library: <a href="https://github.com/riverrun/comeonin" rel="external" target="_blank" class="external">Comeonin</a> with <a href="https://github.com/riverrun/argon2_elixir" rel="external" target="_blank" class="external">Argon2</a>.
For those who don&apos;t know, a password hashing library is different from a normal hashing library in that it is as slow as is <em>sensible</em> - depending on the system you&apos;re on.
This makes bruteforce attacks, i.e.
trying different combinations of passwords until you find a correct one, a lot harder and more resource intensive.</p>
<p>On a testing environment however that is not necessary, so to our <code class="hljs arduino"><span class="hljs-built_in">config</span>/test.exs</code> file we can simply add:</p>
<pre><code class="lang-elixir hljs">config <span class="hljs-symbol">:argon2_elixir</span>,
  <span class="hljs-symbol">t_cost:</span> <span class="hljs-number">2</span>,
  <span class="hljs-symbol">m_cost:</span> <span class="hljs-number">12</span>
</code></pre>
<p>With that we have our token storage covered.
To make it a bit easier to read our data, I would suggest using <a href="https://github.com/meyercm/base_model" rel="external" target="_blank" class="external">BaseModel</a>, which provides an ActiveRecord like access to your ecto schemas.
It removes a lot of overhead when interacting with your data store.</p>
<p>We&apos;re also going to need to include our own authtoken library:</p>
<pre><code class="lang-elixir hljs">{<span class="hljs-symbol">:argon2_elixir</span>, <span class="hljs-string">&quot;~&gt; 1.2&quot;</span>},
{<span class="hljs-symbol">:comeonin</span>, <span class="hljs-string">&quot;~&gt; 4.0&quot;</span>},
{<span class="hljs-symbol">:base_model</span>, <span class="hljs-string">&quot;~&gt; 0.2&quot;</span>},
{<span class="hljs-symbol">:authtoken</span>, <span class="hljs-string">&quot;~&gt; 0.2&quot;</span>},
</code></pre>
<p>At some point in the future we may want to add other parts to our authentication system, like two-factor authentication or email confirmations, but we&apos;ll leave that for a later step and article.</p>
<h2 id="what-does-the-structure-look-like-">What does the structure look like?</h2>
<p>Part of any authentication are three different processes we&apos;re going to have to build:</p>
<ol>
<li>Registration for new users</li>
<li>Login for existing users</li>
<li>Verification for provided authentication tokens</li>
</ol>
<p>We&apos;re definitely going to need to store some user information, and the way to interface to with said store is via a schema.
But before we can access a store, we need to create it:</p>
<pre><code class="lang-shell hljs">mix ecto.gen.migration create_users
</code></pre>
<p>I&apos;m going to give the user a few more fields and features than just the bare-bones version, containing just an email and password field, but you can simplify or extend from that depending on your needs.</p>
<pre><code class="lang-elixir hljs"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">SealasSso</span></span>.Repo.Migrations.CreateUsers <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">use</span> Ecto.Migration

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change</span></span> <span class="hljs-keyword">do</span>
    create table(<span class="hljs-symbol">:users</span>) <span class="hljs-keyword">do</span>
      add <span class="hljs-symbol">:email</span>,                <span class="hljs-symbol">:string</span>
      add <span class="hljs-symbol">:password</span>,             <span class="hljs-symbol">:string</span>, <span class="hljs-symbol">null:</span> <span class="hljs-keyword">true</span>
      add <span class="hljs-symbol">:password_hint</span>,        <span class="hljs-symbol">:string</span>, <span class="hljs-symbol">null:</span> <span class="hljs-keyword">true</span>
      add <span class="hljs-symbol">:active</span>,               <span class="hljs-symbol">:bool</span>,   <span class="hljs-symbol">default:</span> <span class="hljs-keyword">false</span>
      add <span class="hljs-symbol">:activation_code</span>,      <span class="hljs-symbol">:string</span>, <span class="hljs-symbol">size:</span> <span class="hljs-number">32</span>, <span class="hljs-symbol">null:</span> <span class="hljs-keyword">true</span>

      timestamps()
    <span class="hljs-keyword">end</span>

    create unique_index(<span class="hljs-symbol">:users</span>, [<span class="hljs-symbol">:email</span>])

  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Let&apos;s go over these fields, to make sure we&apos;re all on the same page: Ecto&apos;s <code class="hljs gams">create <span class="hljs-keyword">table</span></code> automatically adds the field <code class="hljs applescript"><span class="hljs-built_in">id</span></code> as a table&apos;s primary key, so we have that covered.
That makes it easy to avoid the mistake of using non-permanent data like an e-mail address as the primary key.
We do however use it as a user&apos;s identification token, so it&apos;s necessary to ensure it is unique; thus the additional <code class="hljs">unique_index</code> attached to it.</p>
<p>The password is just a normal text field, but will of course never store a cleartext password.
It is allowed to have a <code class="hljs yaml"><span class="hljs-literal">null</span></code> value, because the registration in Sealas is set up as a two-step process.
First you enter your email address, which you then verify and set your password.
This hints at the reason we include fields <code class="hljs ebnf"><span class="hljs-attribute">active</span></code> and <code class="hljs">activation_code</code>: By default a user is deactivated and gets an activation code attached and sent out by email on creation.</p>
<p>For simplicity&apos;s sake we&apos;ll skip this part for now, but keep these fields in mind.
I&apos;ll expand on this part in the next post.</p>
<p>With our migration set, we can go ahead and create a corresponding schema definition.</p>
<pre><code class="lang-elixir hljs"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">SealasSso</span></span>.Accounts.User <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">use</span> BaseModel, <span class="hljs-symbol">repo:</span> SealasSso.Repo
  import Ecto.Changeset

  <span class="hljs-keyword">alias</span> SealasSso.Accounts.User

  schema <span class="hljs-string">&quot;users&quot;</span> <span class="hljs-keyword">do</span>
    field <span class="hljs-symbol">:email</span>,                <span class="hljs-symbol">:string</span>
    field <span class="hljs-symbol">:password</span>,             EctoHashedPassword
    field <span class="hljs-symbol">:password_hint</span>,        <span class="hljs-symbol">:string</span>
    field <span class="hljs-symbol">:active</span>,               <span class="hljs-symbol">:boolean</span>, <span class="hljs-symbol">default:</span> <span class="hljs-keyword">false</span>
    field <span class="hljs-symbol">:activation_code</span>,      <span class="hljs-symbol">:string</span>

    timestamps()
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>At the top of the file we <code class="hljs actionscript"><span class="hljs-keyword">use</span> BaseModel</code> and tell it the repo file we&apos;re using.
The schema mirrors our migration file except for <code class="hljs ebnf"><span class="hljs-attribute">EctoHashedPassword</span></code>, which automatically transforms all input into its hashed form.
<a href="https://sealas.at/blog/2017-11/custom-ecto-types/">I wrote another post explaining custom ecto types using another type as an example</a>, so I will only add an abbreviated version here.</p>
<h2 id="custom-password-ecto-type">Custom password ecto type</h2>
<p>The base for our custom type will be a string, since we&apos;re going to save the hash as a string to the database.
This makes the whole procedure very simple, as we&apos;re going to base our type on the string ecto type.</p>
<pre><code class="lang-elixir hljs"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">SealasSso</span></span>.EctoHashedPasswordTest <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">use</span> SealasSso.DataCase

  describe <span class="hljs-string">&quot;casting custom ecto hashed password&quot;</span> <span class="hljs-keyword">do</span>
    test <span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-symbol">do:</span> assert EctoHashedPassword.type == <span class="hljs-symbol">:string</span>

    test <span class="hljs-string">&quot;cast and verify&quot;</span> <span class="hljs-keyword">do</span>
      assert {<span class="hljs-symbol">:ok</span>, hash} = EctoHashedPassword.cast(<span class="hljs-string">&quot;test_password&quot;</span>)

      assert EctoHashedPassword.checkpw(<span class="hljs-string">&quot;test_password&quot;</span>, hash)
      assert !EctoHashedPassword.checkpw(<span class="hljs-string">&quot;wrong_password&quot;</span>, hash)
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Since we inherit most functionality from ecto&apos;s native type, we can focus on testing what we would add: the cast function hashing our input and an interface to the verification function of the hash of our choice.</p>
<pre><code class="lang-elixir hljs"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">EctoHashedPassword</span></span> <span class="hljs-keyword">do</span>
  <span class="hljs-variable">@behaviour</span> Ecto.Type
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">type</span></span>, <span class="hljs-symbol">do:</span> <span class="hljs-symbol">:string</span>

  <span class="hljs-variable">@doc</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;
  Hash password with currenly used hashing algorithm
  &quot;</span><span class="hljs-string">&quot;&quot;</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cast</span></span>(password) <span class="hljs-keyword">when</span> is_binary(password), <span class="hljs-symbol">do:</span> {<span class="hljs-symbol">:ok</span>, Comeonin.Argon2.hashpwsalt(password)}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cast</span></span>(<span class="hljs-number">_</span>), <span class="hljs-symbol">do:</span> <span class="hljs-symbol">:error</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load</span></span>(password) <span class="hljs-keyword">when</span> is_binary(password), <span class="hljs-symbol">do:</span> {<span class="hljs-symbol">:ok</span>, password}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load</span></span>(<span class="hljs-number">_</span>), <span class="hljs-symbol">do:</span> <span class="hljs-symbol">:error</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dump</span></span>(password) <span class="hljs-keyword">when</span> is_binary(password), <span class="hljs-symbol">do:</span> {<span class="hljs-symbol">:ok</span>, password}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dump</span></span>(<span class="hljs-number">_</span>), <span class="hljs-symbol">do:</span> <span class="hljs-symbol">:error</span>

  <span class="hljs-variable">@doc</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;
  Check password against hash with currently used hashing algorithm.
  &quot;</span><span class="hljs-string">&quot;&quot;</span>
  <span class="hljs-variable">@spec</span> checkpw(String.t, String.t) <span class="hljs-symbol">:</span>: boolean
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">checkpw</span></span>(password, hash), <span class="hljs-symbol">do:</span> Comeonin.Argon2.checkpw(password, hash)
<span class="hljs-keyword">end</span>
</code></pre>
<p>Since we use Argon2 we implement our type with that.
If at any point we want to change the hashing function to something else, we have it consolidated in one place where we can then simply exchange it.</p>
<p>Well, almost.</p>
<p>To ensure that we&apos;re not breaking anything, let&apos;s add a test verifying that even in case of a future hash change, our previously stored Argon2 hashes still get verified.
Given the hypothetical case that we panic because Argon2 has been completely broken, and we need to change our algorithm NOW, we secure ourselves against forgetting to include the ability to still accept old Argon2 hashes; even if we only output hashes with a different algorithm.
Aren&apos;t tests nifty little buggers?</p>
<pre><code class="lang-elixir hljs"><span class="hljs-variable">@argon2_hash</span> <span class="hljs-string">&quot;$argon2i$v=19$m=65536,t=6,p=1$79ljDB93b7A3W4LsbyoI2A$yiYBzrw1OaQiS86YESKTrwh8l9NnsUpbugddemKPv0w&quot;</span>

test <span class="hljs-string">&quot;verify argon2 hash&quot;</span>, <span class="hljs-symbol">do:</span> assert EctoHashedPassword.checkpw(<span class="hljs-string">&quot;test_password&quot;</span>, <span class="hljs-variable">@argon2_hash</span>)
</code></pre>
<h2 id="authentication-controller">Authentication Controller</h2>
<p>Now that we have our migration, schema and type done, we can move on to the controller part.</p>
<h3 id="let-s-write-some-tests">Let&apos;s write some tests</h3>
<p>to find out and define what we&apos;re going to expect our authentication to look and behave like.</p>
<pre><code class="lang-elixir hljs"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">SealasSso</span></span>.AuthControllerTest <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">use</span> SealasSso.ConnCase

  <span class="hljs-keyword">alias</span> SealasSso.Repo
  <span class="hljs-keyword">alias</span> SealasSso.Accounts.User

  <span class="hljs-variable">@create_attrs</span> %{<span class="hljs-symbol">email:</span> <span class="hljs-string">&quot;some@email.com&quot;</span>, <span class="hljs-symbol">password:</span> <span class="hljs-string">&quot;some password&quot;</span>, <span class="hljs-symbol">active:</span> <span class="hljs-keyword">true</span>}
  <span class="hljs-variable">@valid_login</span>  %{<span class="hljs-symbol">email:</span> <span class="hljs-string">&quot;some@email.com&quot;</span>, <span class="hljs-symbol">password:</span> <span class="hljs-string">&quot;some password&quot;</span>}
  <span class="hljs-variable">@failed_login</span> %{<span class="hljs-symbol">email:</span> <span class="hljs-string">&quot;some@email.com&quot;</span>, <span class="hljs-symbol">password:</span> <span class="hljs-string">&quot;wrong password&quot;</span>}

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fixture</span></span>() <span class="hljs-keyword">do</span>
    {<span class="hljs-symbol">:ok</span>, user} = %User{}
      |&gt; User.create_test_changeset(<span class="hljs-variable">@create_attrs</span>)
      |&gt; Repo.insert()
    user
  <span class="hljs-keyword">end</span>

  setup %{<span class="hljs-symbol">conn:</span> conn} <span class="hljs-keyword">do</span>
    {<span class="hljs-symbol">:ok</span>, <span class="hljs-symbol">conn:</span> put_req_header(conn, <span class="hljs-string">&quot;accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)}
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">defp</span> <span class="hljs-title">create_user</span></span>(<span class="hljs-number">_</span>) <span class="hljs-keyword">do</span>
    user = fixture()
    {<span class="hljs-symbol">:ok</span>, <span class="hljs-symbol">user:</span> user}
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>You&apos;ll notice that our passwords are <em>very</em> simple.
The password&apos;s complexity-check happens on the frontend, in JavaScript.
The frontend in its finished state will never actually send a cleartext password to the backend to perform any such test on it.
This double hashing reduces the likelihood of a leak at any stage of the process.</p>
<p>With this in place, we can now set some test data and setup functions for creating users to test our access with.
Next we can go on and define our actual use cases.</p>
<p>What do we want a successful login to look like?</p>
<pre><code class="lang-elixir hljs">  describe <span class="hljs-string">&quot;login&quot;</span> <span class="hljs-keyword">do</span>
    setup [<span class="hljs-symbol">:create_user</span>]

    test <span class="hljs-string">&quot;successful authentication as a user&quot;</span>, %{<span class="hljs-symbol">conn:</span> conn} <span class="hljs-keyword">do</span>
      conn = get conn, auth_path(conn, <span class="hljs-symbol">:index</span>), <span class="hljs-variable">@create_attrs</span>
      assert %{<span class="hljs-string">&quot;auth&quot;</span> =&gt; auth_token} = json_response(conn, <span class="hljs-number">201</span>)

      assert {<span class="hljs-symbol">:ok</span>, token} = AuthToken.decrypt_token(auth_token)

      {<span class="hljs-symbol">:ok</span>, token_creatd_at} = DateTime.from_unix(token.fields[<span class="hljs-string">&quot;ct&quot;</span>])
      assert DateTime.diff(DateTime.utc_now(), token_creatd_at) &gt;= <span class="hljs-number">0</span>

      conn = conn
      |&gt; recycle()
      |&gt; put_req_header(<span class="hljs-string">&quot;authorization&quot;</span>, <span class="hljs-string">&quot;bearer: &quot;</span> &lt;&gt; auth_token)
      |&gt; get(user_path(conn, <span class="hljs-symbol">:index</span>))

      assert json_response(conn, <span class="hljs-number">200</span>)
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
</code></pre>
<p>The most important part here is actually the first two lines of the test:</p>
<pre><code class="lang-elixir hljs">conn = get conn, auth_path(conn, <span class="hljs-symbol">:index</span>), <span class="hljs-variable">@valid_login</span>
assert %{<span class="hljs-string">&quot;auth&quot;</span> =&gt; auth_token} = json_response(conn, <span class="hljs-number">201</span>)
</code></pre>
<p>Accessing the <code class="hljs">auth_path</code> route should give us a 201 HTTP code response, which stands for &quot;Resoure created&quot;.
That newly created resource is the token it gives us back, which we then use to authenticate further requests.
Then we go on to validate the token with a separate function, and finally go on and try to access a protected route with it.</p>
<p>All that&apos;s missing is covering failure states; failed authentication because of bad credentials, and refused access for a protected route.</p>
<pre><code class="lang-elixir hljs">test <span class="hljs-string">&quot;fail to authenticate with wrong password&quot;</span>, %{<span class="hljs-symbol">conn:</span> conn} <span class="hljs-keyword">do</span>
  conn = get conn, auth_path(conn, <span class="hljs-symbol">:index</span>), <span class="hljs-variable">@failed_login</span>
  assert json_response(conn, <span class="hljs-number">401</span>) == %{<span class="hljs-string">&quot;error&quot;</span> =&gt; <span class="hljs-string">&quot;auth fail&quot;</span>}
<span class="hljs-keyword">end</span>

test <span class="hljs-string">&quot;get 401 for protected route&quot;</span>, %{<span class="hljs-symbol">conn:</span> conn} <span class="hljs-keyword">do</span>
  conn = get conn, user_path(conn, <span class="hljs-symbol">:index</span>)

  assert json_response(conn, <span class="hljs-number">401</span>) == %{<span class="hljs-string">&quot;error&quot;</span> =&gt; <span class="hljs-string">&quot;auth fail&quot;</span>}
<span class="hljs-keyword">end</span>
</code></pre>
<p>This covers our basic usage cases for a login, so:</p>
<h3 id="let-s-implement-it-">Let&apos;s implement it!</h3>
<p>Knowing what our authentication controller is supposed to do, this is pretty straight forward:</p>
<pre><code class="lang-elixir hljs"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">SealasSso</span></span>.AuthController <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">use</span> SealasSso, <span class="hljs-symbol">:controller</span>

  <span class="hljs-keyword">alias</span> SealasSso.Accounts.User
  <span class="hljs-keyword">alias</span> SealasSso.Repo

  <span class="hljs-variable">@spec</span> index(Plug.Conn.t, %{<span class="hljs-symbol">email:</span> String.t, <span class="hljs-symbol">password:</span> String.t}) <span class="hljs-symbol">:</span>: Plug.Conn.t
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span></span>(conn, %{<span class="hljs-string">&quot;email&quot;</span> =&gt; email, <span class="hljs-string">&quot;password&quot;</span> =&gt; password}) <span class="hljs-keyword">do</span>
    user = User.first(<span class="hljs-symbol">email:</span> email)

    <span class="hljs-keyword">cond</span> <span class="hljs-keyword">do</span>
      user &amp;&amp; user.active &amp;&amp; EctoHashedPassword.checkpw(password, user.password) -&gt;
        conn
        |&gt; put_status(<span class="hljs-symbol">:created</span>) <span class="hljs-comment"># http 201</span>
        |&gt; render(<span class="hljs-string">&quot;auth.json&quot;</span>, %{<span class="hljs-symbol">auth:</span> generate_token(user)})
      <span class="hljs-keyword">true</span> -&gt;
        conn
        |&gt; put_status(<span class="hljs-symbol">:unauthorized</span>) <span class="hljs-comment"># http 401</span>
        |&gt; render(<span class="hljs-string">&quot;error.json&quot;</span>)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>We only have two conditions here that will suffice our test cases: A successful login, and a catch-all <code class="hljs ebnf"><span class="hljs-attribute">unauthorized</span></code> error.
If the user exists, is active and has a matching password we can go ahead and generate an authentication token.</p>
<h2 id="working-with-tokens">Working with Tokens</h2>
<p>Our authtoken library is nice enough to prepare us some tokens, but we still have to handle them responsibly in our app.
Two checks are still missing for that: is the token timed out, and is the token stale and needs refreshing?</p>
<p>First, getting a timed out token</p>
<pre><code class="lang-elixir hljs">conn = get conn, auth_path(conn, <span class="hljs-symbol">:index</span>), <span class="hljs-variable">@valid_login</span>
assert %{<span class="hljs-string">&quot;auth&quot;</span> =&gt; auth_token} = json_response(conn, <span class="hljs-number">201</span>)

{<span class="hljs-symbol">:ok</span>, token} = AuthToken.decrypt_token(auth_token)
{<span class="hljs-symbol">:ok</span>, auth_token} = AuthToken.generate_token %{token | <span class="hljs-string">&quot;ct&quot;</span> =&gt; DateTime.utc_now() |&gt; DateTime.to_unix() |&gt; Kernel.-(<span class="hljs-number">864000</span>)}
</code></pre>
<p>Requesting the token is analogous to the login.
Next we&apos;ll decrypt it, and inject a creation time way in the past so it&apos;s going to be timed out -- or at least we expect it to be!</p>
<pre><code class="lang-elixir hljs">conn = conn
|&gt; recycle()
|&gt; put_req_header(<span class="hljs-string">&quot;authorization&quot;</span>, <span class="hljs-string">&quot;bearer: &quot;</span> &lt;&gt; auth_token)
|&gt; get(user_path(conn, <span class="hljs-symbol">:index</span>))

assert json_response(conn, <span class="hljs-number">401</span>) == %{<span class="hljs-string">&quot;error&quot;</span> =&gt; <span class="hljs-string">&quot;timeout&quot;</span>}
</code></pre>
<p>The process for creating tokens that need to be refreshed is exactly the same, we just replace <code class="hljs 1c"><span class="hljs-string">&quot;rt&quot;</span></code> (refresh time) with <code class="hljs 1c"><span class="hljs-string">&quot;ct&quot;</span></code> (creation time); and we&apos;ll test for another message:</p>
<pre><code class="lang-elixir hljs">conn = conn
|&gt; recycle()
|&gt; put_req_header(<span class="hljs-string">&quot;authorization&quot;</span>, <span class="hljs-string">&quot;bearer: &quot;</span> &lt;&gt; stale_token)
|&gt; get(user_path(conn, <span class="hljs-symbol">:index</span>))

assert json_response(conn, <span class="hljs-number">401</span>) == %{<span class="hljs-string">&quot;error&quot;</span> =&gt; <span class="hljs-string">&quot;needs_refresh&quot;</span>}
</code></pre>
<p>But we&apos;re not done here, <code class="hljs">needs_refresh</code> is after all a request to refresh the token to be able to continue working with the API.
So let&apos;s imagine how we&apos;d go about getting a new token.</p>
<pre><code class="lang-elixir hljs">conn = get conn, auth_path(conn, <span class="hljs-symbol">:index</span>), %{<span class="hljs-symbol">token:</span> stale_token}
assert %{<span class="hljs-string">&quot;auth&quot;</span> =&gt; auth_token} = json_response(conn, <span class="hljs-number">201</span>)
</code></pre>
<p>And then let&apos;s retry the request expecting it to be successful this time.</p>
<pre><code class="lang-elixir hljs">conn = conn
|&gt; recycle()
|&gt; put_req_header(<span class="hljs-string">&quot;authorization&quot;</span>, <span class="hljs-string">&quot;bearer: &quot;</span> &lt;&gt; auth_token)
|&gt; get(user_path(conn, <span class="hljs-symbol">:index</span>))

assert json_response(conn, <span class="hljs-number">200</span>)
</code></pre>
<p>The timeout and refresh answer should get handled by the library&apos;s router plug <code class="hljs">verify_token</code>.
What is still missing is the refreshing of stale tokens, which given the easily accessible method `refresh_token`, also shouldn&apos;t be much of a problem:</p>
<pre><code class="lang-elixir hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span></span>(conn, %{<span class="hljs-string">&quot;token&quot;</span> =&gt; auth_token}) <span class="hljs-keyword">do</span>
  {<span class="hljs-symbol">:ok</span>, token} = AuthToken.decrypt_token(auth_token)

  <span class="hljs-keyword">case</span> AuthToken.refresh_token(auth_token) <span class="hljs-keyword">do</span>
    {<span class="hljs-symbol">:ok</span>, token} -&gt;
      conn
      |&gt; put_status(<span class="hljs-symbol">:created</span>)
      |&gt; render(<span class="hljs-string">&quot;auth.json&quot;</span>, %{<span class="hljs-symbol">auth:</span> token})
    <span class="hljs-number">_</span> -&gt;
      conn
      |&gt; put_status(<span class="hljs-symbol">:unauthorized</span>)
      |&gt; render(<span class="hljs-string">&quot;error.json&quot;</span>)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Right on! Either send back a new token, or if it&apos;s any error we can just send back a nondescript error.</p>
<h3 id="ah-but-that-is-not-all-">Ah, but that is not all!</h3>
<p>Refreshing tokens has one actually useful purpose: allowing you to check back with the backend in a longer interval to see if the user is still active, has the correct permissions or even still exists.
So what we have is a good starting point, but needs extending.</p>
<p>The test cases for refreshments need an additional one to ensure that if the user is not valid anymore, we don&apos;t get a new access token.</p>
<pre><code class="lang-elixir hljs">test <span class="hljs-string">&quot;refuse refreshing of token if user has been deleted or deactivated&quot;</span>, %{<span class="hljs-symbol">conn:</span> conn} <span class="hljs-keyword">do</span>
  user = User.first(<span class="hljs-symbol">email:</span> <span class="hljs-variable">@valid_login</span>.email)

  stale_token = create_stale_token(user)

  User.update(user, <span class="hljs-symbol">active:</span> <span class="hljs-keyword">false</span>)

  conn = get conn, auth_path(conn, <span class="hljs-symbol">:index</span>), %{<span class="hljs-symbol">token:</span> stale_token}
  assert json_response(conn, <span class="hljs-number">401</span>)

  User.delete(user)

  conn = get conn, auth_path(conn, <span class="hljs-symbol">:index</span>), %{<span class="hljs-symbol">token:</span> stale_token}
  assert json_response(conn, <span class="hljs-number">401</span>)
<span class="hljs-keyword">end</span>
</code></pre>
<p>Hidden here within <code class="hljs lsl">create_stale_token/<span class="hljs-number">1</span></code>  is the same method to acquire a stale token as above; other than that, we get the user and <code class="hljs aspectj"><span class="hljs-keyword">assert</span></code> getting a 401 if the user is either inactive or deleted.</p>
<p>On the implementation side of things we just need to add the same checks we already use for the normal login process.</p>
<pre><code class="lang-elixir hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span></span>(conn, %{<span class="hljs-string">&quot;token&quot;</span> =&gt; auth_token}) <span class="hljs-keyword">do</span>
  {<span class="hljs-symbol">:ok</span>, token} = AuthToken.decrypt_token(auth_token)

  user = User.first(<span class="hljs-symbol">id:</span> token[<span class="hljs-string">&quot;id&quot;</span>])

  {<span class="hljs-symbol">:ok</span>, token} = AuthToken.refresh_token(auth_token)

  <span class="hljs-keyword">cond</span> <span class="hljs-keyword">do</span>
    user &amp;&amp; user.active &amp;&amp; token -&gt;
      conn
      |&gt; put_status(<span class="hljs-symbol">:created</span>)
      |&gt; render(<span class="hljs-string">&quot;auth.json&quot;</span>, %{<span class="hljs-symbol">auth:</span> token})
    <span class="hljs-keyword">true</span> -&gt;
      conn
      |&gt; put_status(<span class="hljs-symbol">:unauthorized</span>)
      |&gt; render(<span class="hljs-string">&quot;error.json&quot;</span>)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This is also where you could implement more advanced security checks, like following a user&apos;s IP, device, behaviour, etc.
Implementing such heuristics always comes with certain privacy implications that you need to keep in mind, finding a balance between the ability to track a user for the sake of security, and keeping a user&apos;s choices of access anonymous.
Keeping in tune with that, I&apos;ll just announce another article about this topic.</p>
<p>That&apos;s it for now! Next time we&apos;ll tackle verification by email, so stay tuned.</p>

			</div>

			<div class="si-share noborder clearfix">
				<span>Share this Post:</span>
				<div>
					<div id="fb-root"></div>
					<script>(function(d, s, id) {
					  var js, fjs = d.getElementsByTagName(s)[0];
					  if (d.getElementById(id)) return;
					  js = d.createElement(s); js.id = id;
					  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
					  fjs.parentNode.insertBefore(js, fjs);
					}(document, 'script', 'facebook-jssdk'));</script>

						<fb:like href='https://sealas.at/blog/2018-01/designing-and-writing-a-basic-authentication-api-with-phoenix-and-elixir-auth-part-3/'
         send='false'
         layout='button'
         show_faces=''
         width='80'
         action=''
         font=''
         colorscheme=''
         ref='' ></fb:like>

				 <a href="https://twitter.com/share" class="twitter-share-button" data-text="Designing and writing a basic authentication API with Phoenix and Elixir (Auth Part 3)" data-url="https://sealas.at/blog/2018-01/designing-and-writing-a-basic-authentication-api-with-phoenix-and-elixir-auth-part-3/" data-via="SealasApp" data-dnt="true" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

				 <!-- Place this tag where you want the +1 button to render. -->
				<div class="g-plusone" data-size="medium" data-annotation="none" data-callback="https://sealas.at/blog/2018-01/designing-and-writing-a-basic-authentication-api-with-phoenix-and-elixir-auth-part-3/"></div>

				<!-- Place this tag after the last +1 button tag. -->
				<script type="text/javascript">
				  (function() {
				    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
				    po.src = 'https://apis.google.com/js/platform.js';
				    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
				  })();
				</script>

				<script src="//platform.linkedin.com/in.js" type="text/javascript"> lang: en_US</script>
<script type="IN/Share" data-url="https://sealas.at/blog/2018-01/designing-and-writing-a-basic-authentication-api-with-phoenix-and-elixir-auth-part-3/"></script>
				</div>
			</div>

			<div class="post-navigation clearfix">
				<div class="col_half nobottommargin">
					
					<a href="/blog/2018-01/encrypted-auth-tokens-for-phoenix-auth-part-2/"><i class="icon-arrow-left"></i> Encrypted auth tokens for Phoenix (Auth part 2)</a>
					
				</div>
				<div class="col_half col_last tright nobottommargin">
					
					<a href="/blog/2018-02/fortifying-apis-timing-attacks/">Fortifying APIs: timing attacks <i class="icon-arrow-right"></i></a>
					
				</div>
			</div>

		</div>
		<div id="section-buy" class="promo promo-border">

	<div class="clearfix">

		<div id="mc_embed_signup" class="widget subscribe-widget clearfix col-md-10 col-md-offset-1">
			<form action="//sealas.us13.list-manage.com/subscribe/post?u=26cea96bbfb24fbc5f58e314f&amp;id=a92e310c11" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
				<div id="mc_embed_signup_scroll">
				<h3 style="margin-bottom: 1em;"><span>App development, UX design, business:</span> we're writing about the entire development of Sealas</h3>

				<div class="input-group input-group-lg divcenter">
					<span class="input-group-addon"><i class="icon-email2"></i></span>
					<input type="email" value="" required="required" name="EMAIL" class="form-control required email" id="mce-EMAIL" placeholder="Enter your email address here">

					<span class="input-group-btn">
						<button class="btn btn-success" type="submit">Subscribe</button>
					</span>
				</div>
				<div id="mce-responses" class="clear">
					<div class="response" id="mce-error-response" style="display:none"></div>
					<div class="response" id="mce-success-response" style="display:none"></div>
				</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
					<div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_26cea96bbfb24fbc5f58e314f_a92e310c11" tabindex="-1" value=""></div>
					<div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
					</div>
			</form>

			
		</div>
	</div>

</div>

	</div>

</div>
</section>


	<footer id="footer" class="dark" style="background: url('/styles/site/images/footer-bg.jpg') repeat fixed; background-size: 100% 100%;">

		<div class="container">

			
			<div class="footer-widgets-wrap clearfix">

				<div class="col_three_fifth">

					<div class="widget clearfix">

						<img src="/images/sealas-logo-yellow-side.png" alt="Encrypted online accounting for freelancers with Sealas" class="alignleft" id="footer-logo">

						<h3>The <strong>S</strong>ecure <strong>E</strong>asy <strong>A</strong>nd <strong>L</strong>ovely <strong>A</strong>ccounting <strong>S</strong>oftware for freelancers and small businesses.</h3>

						<div class="line" style="margin: 30px 0;"></div>
						<div class="clearfix" style="padding: 10px 0;">
							<div class="col_half">
								<address class="nobottommargin">
									<abbr title="Headquarters" style="display: inline-block;margin-bottom: 7px;"><strong>Imprint:</strong></abbr><br>
									Sealas is a service by<br>
									<a href="https://brainsware.at" target="_blank">Brainsware OG</a><br>
									Liechtensteinstra√üe 119/21<br>
									A-1090 Wien
								</address>
							</div>
							<div class="col_half col_last">
								<br>ATU68014409<br />
								HG Wien, FN 330963k<br />
								<abbr title="Email Address"><strong>Email:</strong></abbr> <a href="mailto:contact@sealas.at">contact@sealas.at</a><br>
								<abbr title="Web"><strong>Web:</strong></abbr> <a href="https://brainsware.at">https://brainsware.at</a><br>
							</div>
						</div>
					</div>

				</div>

				<div class="col_one_fifth">
					<div class="bottommargin-sm widget_links">
						<ul>
							<li><a href="/">Home</a></li>
							<li><a href="/en/about">About us</a></li>
							<li><a href="/#features">Features</a></li>
							
							<li><a href="/en/pricing">Pricing</a></li>
							
							<li><a href="https://github.com/brainsware/sealas-site">Sealas Website on Github</a></li>
							<li><a href="https://github.com/brainsware/sealas">Sealas App on Github</a></li>
						</ul>
					</div>
				</div>
				<div class="col_one_fifth col_last">
					<div class="bottommargin-sm widget_links">
						<ul>
							<li><a href="/en/blog/"><div>Blog</div></a></li>
							<li><a href="/en/contact">Contact</a></li>
							<li><a href="/en/agb">TOS</a></li>
							<li><a href="/en/privacy">Privacy Policy</a></li>
						</ul>
					</div>
				</div>

			</div>

		</div>

		
		<div id="copyrights">

			<div class="container clearfix">

				<div class="col_half">
					&copy; Brainsware OG
				</div>

				<div class="col_half col_last tright">
					<div class="fright clearfix">
						<a href="https://facebook.com/sealasapp" target="_blank" class="social-icon si-small si-borderless nobottommargin si-facebook">
							<i class="icon-facebook"></i>
							<i class="icon-facebook"></i>
						</a>

						<a href="https://twitter.com/sealasapp" target="_blank" class="social-icon si-small si-borderless nobottommargin si-twitter">
							<i class="icon-twitter"></i>
							<i class="icon-twitter"></i>
						</a>

						

						<a href="https://plus.google.com/+SealasAt" target="_blank" class="social-icon si-small si-borderless nobottommargin si-gplus">
							<i class="icon-gplus"></i>
							<i class="icon-gplus"></i>
						</a>

						<a href="https://www.linkedin.com/company/sealas" target="_blank" class="social-icon si-small si-borderless nobottommargin si-linkedin">
							<i class="icon-linkedin"></i>
							<i class="icon-linkedin"></i>
						</a>

						<a href="https://github.com/brainsware" target="_blank" class="social-icon si-small si-borderless nobottommargin si-github">
							<i class="icon-github"></i>
							<i class="icon-github"></i>
						</a>
					</div>
				</div>

			</div>

		</div>

	</footer>

	<script type="text/javascript" src="/site.js">
	</script>

	<noscript><p><img src="//stats.esotericsystems.at/piwik.php?idsite=13" style="border:0;" alt="" /></p></noscript>
</body>
</html>
